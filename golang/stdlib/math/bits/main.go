package main

import (
	"log"
	"math"
	"math/bits"
)

func main() {
	p := math.Pow(2.0, 32.0)
	log.Println(p /*科学计数法表示 4.294967296e+09*/, mi(2, 32), ^uint(0) /*18446744073709551615*/, ^uint(0)>>32 /*4294967295*/, ^uint(0)>>32&1 /*1*/, 32<<(^uint(0)>>32&1) /*64*/, bits.UintSize /*64*/) // 跟平台相关

	// constant 10000000000000000000 overflows int
	var overInt = 1000000000000000000 // 19
	log.Printf("%b\n", overInt)       // 110111100000101101101011001110100111011001000000000000000000 // 60

	for _, x := range []uint{
		0,    // 0 -- 64, 0
		1,    // 1 -- 63, 1
		10,   // 1010 -- 60, 4
		100,  // 1100100 -- 57, 7
		1000, // 1111101000 -- 54, 10
		// 10000,
		// 100000,
		// 1000000,
		// 10000000,
		// 100000000,
		// 1000000000,
		// 10000000000,
		// 100000000000,
		// 1000000000000,
		// 10000000000000,
		// 100000000000000,
		// 1000000000000000,
		// 10000000000000000,
		// 100000000000000000,
		// 1000000000000000000,
		// 10000000000000000000, // 1000101011000111001000110000010010001001111010000000000000000000 -- 0, 64
		// 100000000000000000000, // 21, constant 100000000000000000000 overflows uint
		// 1000101011000111001000110000010010001001111010000000000000000000 // 64
	} {
		log.Printf("===%b\n", x)
		log.Println(bits.LeadingZeros(x)) // 前面0的数量

		log.Println(bits.Len(x)) // 有效位，占据位数

		log.Println(bits.OnesCount(x)) // 1 的数量

		log.Println(bits.TrailingZeros(x)) // 尾随的 0 的数量

		log.Println(bits.RotateLeft(x, 1)) // 左移 1 位，即乘以 2**1

		log.Printf("%b\n", bits.Reverse(x)) // 从右到左，零丢弃
	}
}

// 2**32 = 4294967296 = 4G
func mi(x, y int) int {
	var s = 1
	for i := 0; i < y; i++ {
		s *= x
	}
	return s
}
