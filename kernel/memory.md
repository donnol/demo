# 虚拟地址空间布局

每个进程都有自己的内存，这些内存是由操作系统的虚拟地址空间管理的。

一般来说，32 位的模式中含有 4GB(2 的 32 次方)的内存地址块；64 位的模式中理论最大含有 2097152TB(2 的 64 次方)的内存地址块。

但是，实际实现时跟使用了多少地址总线有关。一般是 内存大小 = 2 的地址总线数量的次方

在一个含有 4GB 内存的 linux 系统里，内核会使用 0xc0000000~0xffffffff 之间的 1GB 内存，剩下 3GB 内存才是用户可以使用的。

    内核空间在所有进程中都映射相同的物理内存。内核代码和数据总是可寻址的，准备随时去处理中断或者系统调用。
    而不同的是，用户模式中的地址空间，在每次进程切换时都会发生变化。

在 3GB 的用户空间里，我们又把它们分为 5 个部分，从 0xc0000000 到 0x0 分别是:

1 栈

    存储本地变量和函数参数
    调用一个方法或者函数将推送一个新的栈帧stack frame到这个栈。当函数返回时这个栈帧被删除
    后进先出(LIFO)
    进程中的每个线程都有它自己的栈
    当申请的栈空间过大时，会引起栈溢出，程序会收到一个段错误(segmentation fault)
    当映射的栈区为满足需要而扩展后，在栈缩小时，映射区域并不会收缩(只增不减)
    除动态栈增长外，去访问一个未映射的内存区域，将触发一个页面故障，导致段故障
    写入只读区域也会触发一个段故障

2 内存映射段(mmap)

    在这里，内核将文件内容直接映射到内存--实现文件 I/O 变得高效
    经常被用于加载动态库
    也被用于去创建一个并不匹配任何文件的匿名内存映射，这种映射经常被用做程序数据的替代
    在 Linux 中，如果你通过 malloc() 去请求一个大(超过了MMAP_THRESHOLD 设置的字节数，它的缺省值是 128 kB，可以通过 mallopt() 去调整)的内存块，C 库将会创建这样一个匿名映射而不是使用堆内存

3 堆

    堆提供运行时内存分配，像栈一样，但又不同于栈的是，它分配的数据生存期要长于分配它的函数
    在 C 中，堆分配的接口是 malloc() 一族，然而在支持垃圾回收的编程语言中，像 C#，这个接口使用 new 关键字
    一般地，堆管理是编程语言运行时和内核共同来做的事情
        如果在堆中有足够的空间可以满足内存请求，它可以由编程语言运行时来处理内存分配请求，而无需内核参与
        否则将通过 brk() 系统调用（代码实现）来扩大堆以满足内存请求所需的大小
    会出现的问题是碎片化

4 BSS(Block Started by Symbol)

    保存 未初始化的  静态变量的内容，它的值在源代码中并没有被程序员设置
    内存区域是 匿名 的：它没有映射到任何文件上

5 数据段(data)

    保存在源代码中静态变量 初始化后 的内容
    内存区域是 非匿名 的。它映射了程序的二进值镜像上的一部分，包含了在源代码中给定初始化值的静态变量内容
    可以通过数据段映射到一个文件，但是这是一个私有内存映射，如果改变内存，它并不会将这种变化反映到底层的文件上(不能改变你磁盘上的二进制文件镜像)

6 文本段(text)

    文本段是只读的，它用于保存你的代码中的类似于字符串常量这样的内容
    文本段也会在内存中映射你的二进制文件，但是，如果你的程序写入到这个区域，将会触发一个段故障错误

工具：

    查看 linux 中进程的内存区域
    sudo cat /proc/1353/maps # 1353 是想查看的进程的PID

    使用 nm 和 objdump 命令去检查二进制镜像，去显示它们的符号、地址、段等等
    nm binfile # binfile 是二进制文件
    objdump [option] binfile # option 是选项，可用 -p -x -S 等

![弹性布局](https://dn-linuxcn.qbox.me/data/attachment/album/201801/18/184944xpqp2n00ee25pmqm.png)

![经典布局](https://dn-linuxcn.qbox.me/data/attachment/album/201801/18/184945j66hejd0e48b5ub6.png)

[来源](https://linux.cn/article-9255-1.html)
