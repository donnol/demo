# 容器和操作系统

## 发行提供了什么？

&emsp;&emsp;现在最流行的 docker 基础容器镜像是 busybox 或 scratch。这是由清教徒和务实主义者推动的。清教徒问“为什么我在运行我的程序前还需要运行 init(1)?”，务实主义者问“为什么我需要一个 700M 基础镜像去部署我的应用？”。同时，寻找不可变部署单元的人会问“我用 ssh 登录到我的容器是一个好主意吗？”。但是，让我们回想一下，在历史里找找，我们是怎么意识到这样的问题存在的。

&emsp;&emsp;在最开始，没有操作系统。程序在运行时占用整台机器。从效能来说，这给这些昂贵的机器的拥有者制造了一个问题。为了最大化他们的投资，在一个程序结束到另一个程序开始的这段时间必须绝对小；于是，监控程序和批量处理诞生了。

&emsp;&emsp;监控器的启动时间不仅仅是看家狗计时器(谷歌翻译的，原文是 Monitors started as barely more than watchdog timers)。它们知道怎么关闭磁带加载下一个程序，如果这个程序跑太长时间会设置一个闹钟。只要时间一走完，监控器成为工作控制-准单一用户操作系统，操作者可以在其上比前面的在读卡器中的串联模型更灵巧地调度批量任务。

&emsp;&emsp;为了解封批量处理的限制，在逐渐增长的计算资源的帮助下，交互式计算诞生了。交互式计算允许多用户直接，时间切片或时间分享地和计算机交互，用户以为自己在完全控制一台计算机的所有资源。

    UNIX 内核是一个I/O多路复用器，而不是一个完整的操作系统。它本应如此。 -- Ken Thompson, BSTJ, 1978.

[原文](https://dave.cheney.net/2018/01/16/containers-versus-operating-systems)
